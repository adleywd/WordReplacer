@page "/"
@using WordReplacer.Enums
@using WordReplacer.Models
@using Microsoft.AspNetCore.Components
@using WordReplacer.Common
@using WordReplacer.Dto
@inject IDocumentService DocumentService
@inject IMatToaster Toaster

<PageTitle>Word Replacer</PageTitle>
<hr/>
<div class="container-fluid">
    <MatPaper Elevation="6" Class="p-3">
        <div class="row">
            <div class="col-12 mt-3">
                <InputFileComponent @bind-Document="_doc"/>
            </div>
        </div>
        <hr/>
        <EditForm Model="_docParamsDto" OnValidSubmit="AddValues">
            <div class="row">
                <div class="col-lg-6 col-md-6 col-sm-12 mt-2">
                    <MatTextField @bind-Value="_docParamsDto.Text"
                                  OnInput="@(e => _docParamsDto.Text = e.Value?.ToString())"
                                  HelperText="The text that will be replaced"
                                  Label="Value to be replaced"
                                  FullWidth="true"/>
                </div>
                <div class="col-lg-6 col-md-6 col-sm-12 mt-2">
                    <label>The field you want for your new input</label>
                    <br/>
                    <MatRadioGroup @bind-Value="_docParamsDto.Type" Items="@(Enum.GetValues(typeof(InputType)).Cast<InputType>())"/>
                </div>
            </div>
            <div class="row">
                <div class="col-12 mb-2 justify-content-center text-center">
                    <MatButton Icon="add"
                               Style="width: 98%"
                               Raised="true"
                               Disabled="_docParamsDto.IsTextEmpty">
                        Add value
                    </MatButton>
                </div>
            </div>
        </EditForm>
    </MatPaper>
    <hr/>
    @if (_doc.DocumentValues.Count > 0)
    {
        <div class="row">
            <div class="col-lg-5 col-md-5 col-sm-12 mt-2">
                <h3>Old values</h3>
            </div>
            <div class="col-lg-5 col-md-5 col-sm-12 mt-2">
                <h3>New values</h3>
            </div>
        </div>
    }
    else
    {
        <div class="alert alert-info justify-content-center">
            <p class="text-center justify-content-center">Select a file and add some values to begin the replacement</p>
        </div>
    }
    <EditForm Model="_doc" OnValidSubmit="HandleSubmitAsync" class="col-12 mt-3">
        <DataAnnotationsValidator/>

        <ValuesInputComponent @bind-Document="_doc" />
        <hr/>
        @if (_doc.DocumentValues.Count > 0) 
        {
            @if (_progressBar)
            {
                <MatProgressBar Class="mb-2" Indeterminate="false" Progress="_progressBarValue"></MatProgressBar>
            }
            <MatButton Icon="@_btnReplaceIcon" Disabled="@(_doc.File is null || _progressBar)" Raised="true">@_btnReplaceText</MatButton>
        }

    </EditForm>
    <SnackbarComponent
        @bind-IsSnackbarOpen="_snackBarIsOpen"
        @bind-Timeout="_snackBarTimeout"
        @bind-HasCloseButton="_snackBarHasCloseButton">
        @_snackBarContent
    </SnackbarComponent>
</div>

@code
{
    private Document _doc = new();
    private readonly DocumentParamsDto _docParamsDto = new();
    
    // Snackbar configs
    private bool _snackBarIsOpen;
    private string _snackBarContent = string.Empty;
    private bool _snackBarHasCloseButton;
    private int _snackBarTimeout = 10000;
    
    // Progress bar configs
    private bool _progressBar;
    private double _progressBarValue;
    
    // Submit btn configs
    private string _btnReplaceText = "Replace and Download";
    private string _btnReplaceIcon = "find_replace";

    private void AddValues()
    {
        var oldValue = new DocumentValue()
        {
            Label = "Old Value",
            HtmlId = Guid.NewGuid().ToString(),
            IsOldValue = true,
            Text = _docParamsDto.Text,
            HelperText = "This is the old value",
            Type = InputType.Text,
            IsAccordionOpen = true
        };
        var newValue = new DocumentValue()
        {
            Label = $"New value for {_docParamsDto.Text}",
            HtmlId = Guid.NewGuid().ToString(),
            IsOldValue = false,
            Text = "",
            HelperText = "This is will be the new value",
            Type = _docParamsDto.Type,
            IsAccordionOpen = true,
            ShouldReplaceForEachLine = _docParamsDto.Type == InputType.List
        };
        _doc.DocumentValues.Add(oldValue, newValue);
        _docParamsDto.Text = string.Empty; // Cleat text field
    }

    private async Task HandleSubmitAsync()
    {
        try
        {
            PrepareUIToReplaceAndDownload();
            
            // TODO: Validate textarea with empty values. It is not working. 
            _doc.DocumentValues.SanitizeValues();
            
            var combinations = new List<Dictionary<string, string>>();
            
            var isThereAnyReplaceForMultipleLine = _doc.DocumentValues.Any(d => d.Value.ShouldReplaceForEachLine);

            if (isThereAnyReplaceForMultipleLine)
            {
                // Get all possible combinations
                combinations = DocumentService.GetAllCombinations(_doc.DocumentValues);
            }
            else
            {
                // Add the single combination to the combination list
                combinations.Add(_doc.DocumentValues
                                     .ToDictionary(
                                         d => d.Key.Text!,
                                         d => d.Value.Text!
                    ));
            }
            
            await DelayDotNetToUpdateUIAsync();
            
            DisplaySnackBar("The site may freezes during the replacing process. Please just wait.", false, -1);
            
            var originalFileInMemoryStream = new MemoryStream();
            if (_doc.File is not null)
            {
                // Get the MemoryStream
                originalFileInMemoryStream = await DocumentService.GetMemoryStream(_doc.File);
                
                await DelayDotNetToUpdateUIAsync();
            }

            var progressSizePerFile = 1.0 / combinations.Count;
            
            foreach (Dictionary<string, string> combination in combinations)
            {
                // Replace
                Stream docReplaced = DocumentService.Replace(combination, originalFileInMemoryStream);
                
                // Get File Name
                var fileName = isThereAnyReplaceForMultipleLine ? string.Join("_", combination.Values) : _doc.File!.Name;
                
                // Download the file
                await DocumentService.DownloadFile($"{fileName}.docx", docReplaced).ConfigureAwait(false);
                
                // Dispose current replaced doc
                await docReplaced.DisposeAsync();
                
                // Update progress UI
                if (combination != combinations.Last())
                {
                    _progressBarValue += progressSizePerFile;
                    ReloadUI();
                 
                    await DelayDotNetToUpdateUIAsync();
                }
            }

            await DelayDotNetToUpdateUIAsync();

            // Dispose the input word file in memory stream
            await originalFileInMemoryStream.DisposeAsync();
            SetDefaultUIAfterDownload();
        }
        catch (Exception ex)
        {
            // DisplaySnackBar("Something went wrong");
            Toaster.Add("Something went wrong, please try again.", MatToastType.Danger, "Error", "");
            SetDefaultUIAfterError();
            ReloadUI();
        }
    }

    // Delay the to UI (Javascript) to catch a breath to update UI
    private static async Task DelayDotNetToUpdateUIAsync(int timeInMs = 100)
    {
        await Task.Delay(timeInMs);
    }
    
    private void PrepareUIToReplaceAndDownload()
    {
        _progressBar = true;
        _btnReplaceText = "Wait, Replacing... ";
        _btnReplaceIcon = "hourglass_empty";
    }

    private void SetDefaultUIAfterDownload()
    {
        _progressBar = false;
        _snackBarIsOpen = false;
        _progressBarValue = 0;
        SetDefaultValuesForBtnReplace();
    }
    
    private void SetDefaultUIAfterError()
    {
        _progressBar = false;
        SetDefaultValuesForBtnReplace();
    }

    private void SetDefaultValuesForBtnReplace()
    {
        _btnReplaceText = "Replace and Download";
        _btnReplaceIcon = "find_replace";
    }

    private void DisplaySnackBar(string textMessage, bool hasCloseButton = true, int timeout = 100) // 10000
    {
        if (_snackBarIsOpen)
        {
            _snackBarIsOpen = false;
        }
        
        _snackBarIsOpen = true;
        _snackBarContent = textMessage;
        _snackBarHasCloseButton = hasCloseButton;
        _snackBarTimeout = timeout;
        ReloadUI();
    }

    private void ReloadUI()
    {
        InvokeAsync(StateHasChanged);
    }

}